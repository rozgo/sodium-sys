initSidebarItems({"fn":[["allocarray","The *allocarray()* function returns a mutable byte array."],["bin2hex","The *bin2hex()* function converts a byte sequence into a hexadecimal string."],["free","The *free()* function unlocks and deallocates memory allocated using *malloc()* or *allocarray()*."],["hex2bin","The *hex2bin()* function parses a hexadecimal string and converts it to a byte sequence."],["increment","The *increment()* function takes a pointer to an arbitrary length unsigned number, and increments it."],["malloc","The *malloc()* function returns a mutable array of bytes."],["memcmp","When a comparison involves secret data (e.g. key, authentication tag), is it critical to use a constant-time comparison function in order to mitigate side-channel attacks."],["memzero","After use, sensitive data should be overwritten, but *memset()* and hand-written code can be silently stripped out by an optimizing compiler or by the linker."],["mlock","The *mlock()* function locks the bytes of the given array. This can help avoid swapping sensitive data to disk."],["mprotect_noaccess","The *mprotect_noaccess()* function makes a region allocated using *malloc()*  or *allocarray()* inaccessible. It cannot be read or written, but the data are preserved."],["mprotect_readonly","The *mprotect_readonly()* function marks a region allocated using *malloc()* or *allocarray()* as read-only."],["mprotect_readwrite","The *mprotect_readwrite()* function marks a region allocated using *malloc()* or *allocarray()* as readable and writable, after having been protected using *mprotect_readonly()* or *mprotect_noaccess()*."],["munlock","The *munlock()* function should be called after locked memory is not being used any more. It will zero the bytes in the array before actually flagging the pages as swappable again. Calling *memzero()* prior to *munlock()* is thus not required."]]});